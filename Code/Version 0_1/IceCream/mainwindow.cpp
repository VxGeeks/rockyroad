  #include "mainwindow.h"
#include "ui_mainwindow.h"
#include "qfiledialog.h"
#include <QDateTime>
#include <QTimer>
#include <QTextStream>
#include <fcntl.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include <wiringPi.h>
#include <wiringPiI2C.h>
#include <wiringPiSPI.h>

extern "C" {
#include "IC.h"
#include "IC_Init.h"
#include "Display_Mode.h"
}

#include "bma2x2.h"
#include "bmm050.h"

//Private
QFileInfo fileInfo;
QImage imageIn;
int i2cH_BMA;
int i2cH_BMM;

//Public
QString JoyStick_Status;


MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    QTimer *timedService = new QTimer(this);
    connect(timedService, SIGNAL(timeout()), this, SLOT(update()) );

    initVxHat();

    timedService->start(40);

}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::update()
{
    // Update Joystick Status
    ui->label_JoyStick->setText(JoyStick_Status);

    // Pull IMU Data

    //V_pinture();
    //Column_Show1();


}

void MainWindow::on_pushButton_LoadImage_clicked()
{

   QString filename = QFileDialog::getOpenFileName(this,
                     tr("Load an Image file"), "/home", tr("Image Files (*.png *.jpg *.jpeg *.bmp)"));
   if (loadImage(filename))
   {   
       ui->pushButton_SaveAsCCode->setEnabled(true);

       for (int i = 0; i < ui->listWidget_History->count(); i++)
       {
           if( !QString::compare( ui->listWidget_History->itemAt(i,0)->whatsThis(), filename, Qt::CaseInsensitive))
           {
              return;
           }
       }

       QListWidgetItem *item = new QListWidgetItem();
       item->setText(filename.section('/',-1));
       item->setWhatsThis(filename);

       ui->listWidget_History->addItem(item);
   }
   else
   {
       ui->pushButton_SaveAsCCode->setDisabled(true);
   }

}


// Support Methods

int MainWindow::loadImage(QString filename)
{

    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly))
           return 0;

    imageIn.load(filename);

    file.close();

    QFileInfo NewfileInfo(filename);

    if (imageIn.height() > 256 || imageIn.width() > 256 )
    {
        ui->label_Filename->setText("File Error: " + NewfileInfo.fileName() + " - Image size is too big. Please check your file and try again.");
        return 0;
    }

    fileInfo = NewfileInfo;

    ui->label_Filename->setText(fileInfo.fileName());


    imageIn = imageIn.convertToFormat(QImage::Format_Mono);

    int width = imageIn.width(), height = imageIn.height();

    //Setup output for C Header file

    QDateTime dt = QDateTime::currentDateTime();

    ui->textBrowser_CHeaderOutput->clear();

    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Header file for " + fileInfo.fileName() + "." );
    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Image Size: " + QString::number(width) + " x " + QString::number(height));
    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Generated by Visionox | VxD on " + dt.toString( "ddd, d MMM yyyy hh:mm:ss" ));
    ui->textBrowser_CHeaderOutput->append("//");

    ui->textBrowser_CHeaderOutput->append("");
    ui->textBrowser_CHeaderOutput->append("");
    ui->textBrowser_CHeaderOutput->append("const char array_image_" + ((fileInfo.fileName()).section('.', 0,0)).replace(" ","_") + "[] = " );
    ui->textBrowser_CHeaderOutput->append("{" );


    QColor color;

    int pixelCount = 0;
    unsigned char byteData = 0;
    QString RowPixels = "";

    for (int y=0; y<height; y++)
    {
       ui->textBrowser_CHeaderOutput->append("");
       RowPixels = "";

        for (int x=0; x<width; x++)
        {
            ++pixelCount;

            color = imageIn.pixel(x, y);

            //int r = color.red();
            //int g = color.green();
            //int b = color.blue();

            if (color.red() < 127 || color.green() < 127 || color.blue() < 127 )
            {
                imageIn.setPixel(x, y, 1);
                byteData = byteData | 0x80;
            }
            else
            {
                imageIn.setPixel(x, y, 0);
            }

            if ((pixelCount % 8) == 0)
            {
                QByteArray array((char * )&byteData, 1);

                RowPixels = RowPixels + " 0x" + QString(array.toHex()) + ",";

                byteData = 0;
            }
            else
            {
                byteData>>=1;
            }
        }
         ui->textBrowser_CHeaderOutput->append(RowPixels);
    }


    ui->textBrowser_CHeaderOutput->append("" );
    ui->textBrowser_CHeaderOutput->append("};" );


    QGraphicsScene *scene = new QGraphicsScene (this);
    imageIn.invertPixels(QImage::InvertRgba);
    QPixmap pixmap = QPixmap::fromImage(imageIn);
    scene->addPixmap(pixmap);

    //int gVWidth = ((int)(256 / imageIn.width())) * imageIn.width();
    int gVHeight = ((int)(256 * imageIn.height())) / imageIn.width();

    ui->graphicsView_OLEDImage->resize(256, gVHeight);
    ui->graphicsView_OLEDImage->setScene(scene);
    ui->graphicsView_OLEDImage->fitInView(scene->sceneRect(),Qt::KeepAspectRatio);

    return 1;

}



void MainWindow::on_listWidget_History_itemDoubleClicked(QListWidgetItem *item)
{
    loadImage(item->whatsThis());
}

void MainWindow::on_pushButton_SaveAsCCode_clicked()
{
    QString filename = QFileDialog::getSaveFileName(this,"Save " + fileInfo.fileName() + " as C file", fileInfo.path() + "/" + (fileInfo.fileName().section('.', 0,0)).replace(" ","_") + ".c"  ,"C File (*.c)");

    QFile file(filename);

    if ( file.open(QIODevice::ReadWrite) )
    {
        QTextStream stream( &file );
        stream << ui->textBrowser_CHeaderOutput->toPlainText();
    }
    file.flush();
    file.close();
}

int MainWindow::initVxHat()
{

    // ******************* Setup I/O ***********************

    typedef void (*FunctionType)(void); //< We call the pointer to function type FunctionType (the line is optional and for simplicity).
    FunctionType pointerToJoyUP_INT = &MainWindow::JoyUP_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.
    FunctionType pointerToJoyDOWN_INT = &MainWindow::JoyDOWN_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.
    FunctionType pointerToJoyRIGHT_INT = &MainWindow::JoyRIGHT_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.
    FunctionType pointerToJoyLEFT_INT = &MainWindow::JoyLEFT_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.
    FunctionType pointerToJoySELECT_INT = &MainWindow::JoySELECT_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.

    wiringPiSetup();

    // On-board button Input:

    pinMode (15, INPUT) ; //UP
    pullUpDnControl(15, PUD_UP); // Pull-UP
    wiringPiISR(15, INT_EDGE_FALLING, pointerToJoyUP_INT);

    pinMode (1, INPUT) ; //RIGHT
    pullUpDnControl(1, PUD_UP); // Pull-UP
    wiringPiISR(1, INT_EDGE_FALLING, pointerToJoyRIGHT_INT);

    pinMode (0, INPUT) ; //LEFT
    pullUpDnControl(0 ,PUD_UP); // Pull-UP
    wiringPiISR(0, INT_EDGE_FALLING, pointerToJoyLEFT_INT);

    pinMode (16, INPUT) ; //SELECT
    pullUpDnControl(16, PUD_UP); // Pull-UP
    wiringPiISR(16, INT_EDGE_FALLING, pointerToJoySELECT_INT);

    pinMode (2, INPUT) ; //DOWN
    pullUpDnControl(2 ,PUD_UP); // Pull-UP
    wiringPiISR(2, INT_EDGE_FALLING, pointerToJoyDOWN_INT);


    // OLED SPI DRIVER PINS
    pinMode (RES, OUTPUT) ; //RESET
    pinMode (DC, OUTPUT) ; //Data/Command

    //***************** Setup Display *****************

    if ((wiringPiSPISetup(0,1000000)) < 0)
    {
        return 0;
    }
    else
    {
        Reset_IC();
        Init_IC();

        Chess_Board1();
        delay(500);
        Clear_Screen();
        delay(500);        //Column_Scan();
    }






    QString msgRec = "Trying to connect...";

    if((i2cH_BMA = wiringPiI2CSetup(BMA2x2_I2C_ADDR1)) < 0 )
    {
        /* ERROR HANDLING: you can check errno to see what went wrong */
        perror("Failed to open the i2c bus");

        ui->label_Status->setText("VxD OLEDHAT not found :(");

        return 0;
    }
    else
    {

        ui->label_Status->setText("VxD OLEDHAT found :)");

        int chipID = wiringPiI2CReadReg8 (i2cH_BMA, BMA2x2_CHIP_ID_ADDR) ;
        //delayMicroseconds(1000);
        //int bsSWV = wiringPiI2CReadReg8 (i2cHandle,BNO055_SW_REV_ID_LSB_ADDR);

        msgRec += " Connected :) BMA ID = 0x" + QString::number( chipID, 16 ).toUpper();

        ui->label_Status->setText(msgRec);

    }

    if((i2cH_BMM = wiringPiI2CSetup(BMM050_I2C_ADDRESS)) < 0 )
    {
        /* ERROR HANDLING: you can check errno to see what went wrong */
        perror("Failed to open the i2c bus");

        ui->label_Status->setText("VxD OLEDHAT not found :(");

        return 0;
    }
    else
    {

        int chipID = wiringPiI2CReadReg8 (i2cH_BMM, BMM050_CHIP_ID) ;
        //delayMicroseconds(1000);
        //int bsSWV = wiringPiI2CReadReg8 (i2cHandle,BNO055_SW_REV_ID_LSB_ADDR);

        msgRec += " BMM ID = 0x" + QString::number( chipID, 16 ).toUpper();

        ui->label_Status->setText(msgRec);

    }


    return 1;
}

void MainWindow::JoyUP_INT()
{

    JoyStick_Status = "UP";
}

void MainWindow::JoyDOWN_INT()
{

    JoyStick_Status = "DOWN";
}

void MainWindow::JoyLEFT_INT()
{

    JoyStick_Status = "LEFT";
}

void MainWindow::JoyRIGHT_INT()
{

    JoyStick_Status = "RIGHT";
}

void MainWindow::JoySELECT_INT()
{

    JoyStick_Status = "SELECT";
}
