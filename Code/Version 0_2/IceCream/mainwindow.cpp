#include "mainwindow.h"
#include "ui_mainwindow.h"

//App Specific QT Includes
#include "qfiledialog.h"
#include <QDateTime>
#include <QTimer>
#include <QTextStream>

//WiringPi Includes
#include <wiringPi.h>
#include <wiringPiI2C.h>
#include <wiringPiSPI.h>

// Displays Specific Includes
extern "C" {
#include "IC.h"
#include "IC_Init.h"
#include "Display_Mode.h"
}

// Bosch Sensor Specific Includes
#include "bma2x2.h"
#include "bmm050.h"
#include "bmg160.h"



//Private
QFileInfo fileInfo;
QImage imageIn;

// Bosch Sensor i2c Addresses
int i2cH_BMA;
int i2cH_BMM;
int i2cH_BMG;


QVector<char> ImageInArray;

//Public
QString JoyStick_Status;


MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui->setupUi(this);

    QTimer *timedService = new QTimer(this);
    connect(timedService, SIGNAL(timeout()), this, SLOT(update()) );

    // Initialize the Ice Cream HAT
    if (initIceCreamHat())
    {
        // Turn on interrupt timer
        timedService->start(40);
    }

}

MainWindow::~MainWindow()
{
    delete ui;
}

void MainWindow::update()
{
    // Update Joystick Status
    ui->label_JoyStick->setText(JoyStick_Status);

    // Pull IMU Data

    //Gyro
    signed int gyrX = wiringPiI2CReadReg16 (i2cH_BMG, BMG160_RATE_X_LSB_ADDR);
    ui->label_gyrX->setText(QString::number(gyrX));

    signed int gyrY = wiringPiI2CReadReg16 (i2cH_BMG, BMG160_RATE_Y_LSB_ADDR);
    ui->label_gyrY->setText(QString::number(gyrY));

    signed int gyrZ = wiringPiI2CReadReg16 (i2cH_BMG, BMG160_RATE_Z_LSB_ADDR);
    ui->label_gyrZ->setText(QString::number(gyrZ));


    //Accelerometer
    signed int accX = wiringPiI2CReadReg16 (i2cH_BMA, BMA2x2_X_AXIS_LSB_ADDR);
    ui->label_accX->setText(QString::number(accX));

    signed int accY = wiringPiI2CReadReg16 (i2cH_BMA, BMA2x2_Y_AXIS_LSB_ADDR);
    ui->label_accY->setText(QString::number(accY));

    signed int accZ = wiringPiI2CReadReg16 (i2cH_BMA, BMA2x2_Z_AXIS_LSB_ADDR);
    ui->label_accZ->setText(QString::number(accZ));

    /*
    //Magnotometer
    signed int magX = wiringPiI2CReadReg16 (i2cH_BMM, BMM050_DATA_X_LSB);
    ui->label_accX->setText(QString::number(magX));

    signed int magY = wiringPiI2CReadReg16 (i2cH_BMM, BMM050_DATA_Y_LSB);
    ui->label_accY->setText(QString::number(magY));

    signed int magZ = wiringPiI2CReadReg16 (i2cH_BMM, BMM050_DATA_Z_LSB);
    ui->label_accZ->setText(QString::number(magZ));

    signed int magR = wiringPiI2CReadReg16 (i2cH_BMM, BMM050_DATA_R_LSB);
    ui->label_accZ->setText(QString::number(magR));
    */

}

void MainWindow::on_pushButton_LoadImage_clicked()
{

   QString filename = QFileDialog::getOpenFileName(this,
                     tr("Load an Image file"), "/home", tr("Image Files (*.png *.jpg *.jpeg *.bmp)"));
   if (loadImage(filename))
   {   
       ui->pushButton_SaveAsCCode->setEnabled(true);

       /*for (int i = 0; i < ui->listWidget_History->count(); i++)
       {
           if( !QString::compare( ui->listWidget_History->itemAt(i,0)->whatsThis(), filename, Qt::CaseInsensitive))
           {
              return;
           }
       }*/

       QListWidgetItem *item = new QListWidgetItem();
       item->setText(filename.section('/',-1));
       item->setWhatsThis(filename);

       //ui->listWidget_History->addItem(item);
   }
   else
   {
       ui->pushButton_SaveAsCCode->setDisabled(true);
   }

}


// Support Methods

// File load functions
int MainWindow::loadImage(QString filename)
{

    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly))
           return 0;

    imageIn.load(filename);

    file.close();

    QFileInfo NewfileInfo(filename);

    if (imageIn.height() > 256 || imageIn.width() > 256 )
    {
        ui->label_Filename->setText("File Error: " + NewfileInfo.fileName() + " - Image size is too big. Please check your file and try again.");
        return 0;
    }

    fileInfo = NewfileInfo;

    ui->label_Filename->setText(fileInfo.fileName());


    imageIn = imageIn.convertToFormat(QImage::Format_Mono);

    int width = imageIn.width(), height = imageIn.height();

    //Setup output for C Header file

    QDateTime dt = QDateTime::currentDateTime();

    ui->textBrowser_CHeaderOutput->clear();

    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Header file for " + fileInfo.fileName() + "." );
    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Image Size: " + QString::number(width) + " x " + QString::number(height));
    ui->textBrowser_CHeaderOutput->append("//");
    ui->textBrowser_CHeaderOutput->append("// Generated by Visionox | VxD on " + dt.toString( "ddd, d MMM yyyy hh:mm:ss" ));
    ui->textBrowser_CHeaderOutput->append("//");

    ui->textBrowser_CHeaderOutput->append("");
    ui->textBrowser_CHeaderOutput->append("");
    ui->textBrowser_CHeaderOutput->append("const char array_image_" + ((fileInfo.fileName()).section('.', 0,0)).replace(" ","_") + "[] = " );
    ui->textBrowser_CHeaderOutput->append("{" );


    QColor color;
    unsigned char byteData = 0;
    QString ColPixels = "";

    ImageInArray.clear();

    for (int bank=0; bank<height/8; bank++)
    {
        ColPixels = "";

        for (int x=0; x<width; x++)
        {
            byteData = 0;

            for (int y=(0 + (bank*8)); y<(8+(bank*8)); y++)
            {
                color = imageIn.pixel(x, y);

                //int r = color.red();
                //int g = color.green();
                //int b = color.blue();

                byteData>>=1;

                if (color.red() > 127 || color.green() > 127 || color.blue() > 127 )
                //if ((color.red() + color.green() + color.blue())/3 > 127 )
                {
                    imageIn.setPixel(x, y, 1);
                    byteData = byteData | 0x80;
                }
                else
                {
                    imageIn.setPixel(x, y, 0);
                    byteData = byteData & 0x7F;
                }

            }

            //Store Image Data in Memory
            ImageInArray.append(byteData);

            //Write Image Data to Screen to save to file later
            QByteArray array((char * )&byteData, 1);

            ColPixels = ColPixels + " 0x" + QString(array.toHex()) + ",";
        }

        ui->textBrowser_CHeaderOutput->append(ColPixels);
    }

    ui->textBrowser_CHeaderOutput->append("" );
    ui->textBrowser_CHeaderOutput->append("};" );


    QGraphicsScene *scene = new QGraphicsScene (this);
    imageIn.invertPixels(QImage::InvertRgba);
    QPixmap pixmap = QPixmap::fromImage(imageIn);
    scene->addPixmap(pixmap);

    //int gVWidth = ((int)(256 / imageIn.width())) * imageIn.width();
    int gVHeight = ((int)(256 * imageIn.height())) / imageIn.width();

    ui->graphicsView_OLEDImage->resize(256, gVHeight);
    ui->graphicsView_OLEDImage->setScene(scene);
    ui->graphicsView_OLEDImage->fitInView(scene->sceneRect(),Qt::KeepAspectRatio);

    Image_Show();

    return 1;

}


void MainWindow::on_pushButton_SaveAsCCode_clicked()
{
    QString filename = QFileDialog::getSaveFileName(this,"Save " + fileInfo.fileName() + " as C file", fileInfo.path() + "/" + (fileInfo.fileName().section('.', 0,0)).replace(" ","_") + ".c"  ,"C File (*.c)");

    QFile file(filename);

    if ( file.open(QIODevice::ReadWrite) )
    {
        QTextStream stream( &file );
        stream << ui->textBrowser_CHeaderOutput->toPlainText();
    }
    file.flush();
    file.close();
}


//Initialize Ice Cream
int MainWindow::initIceCreamHat()
{

    // Setup wiringPi to enable i/o and other port related functions

    wiringPiSetup();


    // Check if the Bosch BMX055 Sensor is present

    ui->label_Status->setText("Trying to connect...");

    QString msgRec = "";

    if((i2cH_BMA = wiringPiI2CSetup(BMA2x2_I2C_ADDR1)) < 0 )
    {
        /* ERROR HANDLING: you can check errno to see what went wrong */
        perror("Failed to open the i2c bus");

        ui->label_Status->setText("Rocky Road not found (X)");

        return 0;
    }
    else
    {

        ui->label_Status->setText("Something found...");

        int chipID = wiringPiI2CReadReg8 (i2cH_BMA, BMA2x2_CHIP_ID_ADDR) ;
        //delayMicroseconds(1000);
        //int bsSWV = wiringPiI2CReadReg8 (i2cHandle,BNO055_SW_REV_ID_LSB_ADDR);

        msgRec += "BMA ID = 0x" + QString::number( chipID, 16 ).toUpper();

        ui->label_Status->setText(msgRec);

    }

    if((i2cH_BMG = wiringPiI2CSetup(BMG160_I2C_ADDR1)) < 0 )
    {
        /* ERROR HANDLING: you can check errno to see what went wrong */
        perror("Failed to open the i2c bus");

        ui->label_Status->setText("Rocky Road not found (X)");

        return 0;
    }
    else
    {

        ui->label_Status->setText("Something found...");

        int chipID = wiringPiI2CReadReg8 (i2cH_BMG, BMG160_CHIP_ID_ADDR) ;
        //delayMicroseconds(1000);
        //int bsSWV = wiringPiI2CReadReg8 (i2cHandle,BNO055_SW_REV_ID_LSB_ADDR);

        msgRec += " BMG ID = 0x" + QString::number( chipID, 16 ).toUpper();

        ui->label_Status->setText(msgRec);

    }

    if((i2cH_BMM = wiringPiI2CSetup(BMM050_I2C_ADDRESS)) < 0 )
    {
        /* ERROR HANDLING: you can check errno to see what went wrong */
        perror("Failed to open the i2c bus");

        ui->label_Status->setText("Rocky Road not found (X)");

        return 0;
    }
    else
    {

        int chipID = wiringPiI2CReadReg8 (i2cH_BMM, BMM050_CHIP_ID) ;
        //delayMicroseconds(1000);
        //int bsSWV = wiringPiI2CReadReg8 (i2cHandle,BNO055_SW_REV_ID_LSB_ADDR);

        msgRec += " BMM ID = 0x" + QString::number( chipID, 16 ).toUpper();

        msgRec = "Rocky Road connected! " + msgRec;

        ui->label_Status->setText(msgRec);

    }




    // ******************* Setup I/O ***********************

    // Setup pointers to funtions that will need to be passed through as paramters to other functions
    typedef void (*FunctionType)(void); //< We call the pointer to function type FunctionType (the line is optional and for simplicity).
    FunctionType pointerToJoyUP_INT = &MainWindow::JoyUP_INT; //< Literally means get the address of MyClass::someFunction and save it in the pointerToFunction variable.
    FunctionType pointerToJoyDOWN_INT = &MainWindow::JoyDOWN_INT;
    FunctionType pointerToJoyRIGHT_INT = &MainWindow::JoyRIGHT_INT;
    FunctionType pointerToJoyLEFT_INT = &MainWindow::JoyLEFT_INT;
    FunctionType pointerToJoySELECT_INT = &MainWindow::JoySELECT_INT;



    // On-board Joystick Input:

    pinMode (15, INPUT) ; //UP
    pullUpDnControl(15, PUD_UP); // Pull-UP
    wiringPiISR(15, INT_EDGE_FALLING, pointerToJoyUP_INT);

    pinMode (1, INPUT) ; //RIGHT
    pullUpDnControl(1, PUD_UP); // Pull-UP
    wiringPiISR(1, INT_EDGE_FALLING, pointerToJoyRIGHT_INT);

    pinMode (0, INPUT) ; //LEFT
    pullUpDnControl(0 ,PUD_UP); // Pull-UP
    wiringPiISR(0, INT_EDGE_FALLING, pointerToJoyLEFT_INT);

    pinMode (16, INPUT) ; //SELECT
    pullUpDnControl(16, PUD_UP); // Pull-UP
    wiringPiISR(16, INT_EDGE_FALLING, pointerToJoySELECT_INT);

    pinMode (2, INPUT) ; //DOWN
    pullUpDnControl(2 ,PUD_UP); // Pull-UP
    wiringPiISR(2, INT_EDGE_FALLING, pointerToJoyDOWN_INT);


    // OLED SPI DRIVER PINS
    pinMode (RES, OUTPUT) ; //RESET
    pinMode (DC, OUTPUT) ; //Data/Command

    //***************** Setup Display *****************

    // Setup SPI for 1Mbit/s
    if ((wiringPiSPISetup(0,1000000)) < 0)
    {
        return 0;
    }
    else
    {
        Reset_IC();
        Init_IC();
    }

    return 1;
}


// Load Image to Dislays
void MainWindow::Image_Show()
{
   uchar page_number,column_number;
   uint pixel=MIN;
   for(page_number=MIN;page_number<PAGE_TOTAL/2;page_number++)
   {
      Write_Command(START_PAGE+page_number);
      Write_Command(START_HIGH_BIT);
      Write_Command(START_LOW_BIT);
      for(column_number=MIN;column_number<COLUMN_MAX;column_number++)
      {
         Write_Data(ImageInArray.at(pixel));
         pixel++;
      }
  }
}


// Joystick functions
void MainWindow::JoyUP_INT()
{

    JoyStick_Status = "UP";
    Chess_Board1();

}

void MainWindow::JoyDOWN_INT()
{

    JoyStick_Status = "DOWN";

    All_Screen();
}

void MainWindow::JoyLEFT_INT()
{

    JoyStick_Status = "LEFT";

    V_pinture();
}

void MainWindow::JoyRIGHT_INT()
{

    JoyStick_Status = "RIGHT";

    Clear_Screen();
}

void MainWindow::JoySELECT_INT()
{

    JoyStick_Status = "SELECT";

    Image_Show();

}



